/************************************************************************************************************/
/*                                                                                                          */
/*                                              MobileRobot.c                                               */
/*                                                                                                          */
/*                                                                                       2020. 1. 1.        */
/************************************************************************************************************/
#include "Interface.h"

// 옵션에서(톱니바퀴)	-> libraries -> liba.a & libm.a 추가
// 옵션에서(톱니바퀴)	-> General -> Frequency 14745600 설정
// Interface.c 		 	-> Camera Baud Rate Setting : (USART1 Baud Rate: 115200)(통신속도)(UBRR1L=0x5F -> UBRR1L=0x07)
// Interface.c 			-> ISR Camera_V1 Setting
// Interface.c			-> lcd_clear_screen()을 cls()로 display_char()을 dc()로
// Interface.c 			-> Interface_init()에 putchar1(18); 추가 (카메라 V1 프로토콜 사용)
// Motor.c 			 	-> SetGain 10, 3, 1 Setting
// Sensor.c				-> Sensor_init()에 DDRD  &= ~0x50; 추가
// Sensor.h				-> READ_SENSOR()를 S로 변경
// Sensor.h				-> S에 | (~(PIND<<1)&0x20) | (~PIND&0x40) 추가

char debug;

#define rev_stdir (-stdir)
#define rev_dir (!dir)
#define rev_num (9-num)
#define rev_ta (ta==135 ? 165:135)

int stdir, dir, num, ta;

void set(int mode){//돌아갈 떄 사용, 어디로 돌아갈지에 따라 int stdir, dir, num, ta 변수 값을 정해주는 함수
	if(mode) stdir=1, dir=1, num=8, ta=135;
	else stdir=-1, dir=0, num=1, ta=165;
}

int T; // 맵에서 기준이 되는 선 값을 저장하는 변수
int G1;// G1_gate가 T와 같다면 1, 다르다면 0 (돌아올 때 어디로 출발햇는지 구별할 수 있음)
int G1_gate;//G1구역을  통과하기 위해 (출발/도착에 가까가운 G1)  값을 저장하는 변수
int A;//A구역 가변벽(통과 가능 한 곳)을 통과할 떄 사용하는 변수(& : 1) (% : 2) (/ : 3)

void attack3(int m){//퍽이 3개 있을 경우 사용하는 함수 

	int tmp[3];//퍽 색깔을 담을 배열 
	if(m) V1(0,0,1,0,0,180,0,240,130,120,1);//매개변수가 들어오면 추적 
	else V1(1,0,0,0,0,180,0,240,0,0,0);//들어오지 않으면  색 저장 
	for(int i=0;i<3;i++) tmp[i]=C_D[i][0];//퍽 색깔을 tmp 배열에 저장 
	for(int i=0;i<3;i++){
		if(tmp[i]==T){
			ping(3);
			V1(0,i,0,T,0,145,0,240,0,120,2);
			HM(-pw[3],500,11,70,0,0);
			HM(-pw[3],500,11,-70,0,0);
			LM(3,0,100,11,px[3],py[3],0,0);
		}
	}
}
void attack2(int m){//퍽이 2개 있을 경우 사용하는 함수 
	int tmp[2];
	T=2;
	V1(1,0,0,0,0,180,0,240,0,0,0);
	for(int i=0;i<2;i++) tmp[i]=C_D[i][0];
	for(int i=0;i<2;i++){
		if(tmp[i]==T){
			if(m){
				ping(3);
				V1(0,i,0,0,0,180,0,240,130,120,3);
				HM(0,500,11,70,0,0);
				HM(0,500,11,-70,0,0);
				LM(3,300,100,11,0,0,0,0);
			}
			else{
				ping(3);
				V1(0,i,0,0,0,180,0,240,0,120,2);
				HM(-pw[3],500,11,100,0,0);
				HM(-pw[3],500,11,-100,0,0);
				LM(3,0,150,11,px[3],py[3],0,0); 
			}
		}
	}
}
void M1()//시작 & 3개 퍽 처리하는 코드
{
	HM(0,300,11,50,0,0);
	FCC(1,2,1,165);//psd[1] 센서로 value : 165를 맞추며 뒷 보정  
	
	TD(0,400,11,250,0,92,0);
	FCC(2,2,0,0);
	Pm(0,2,2,150,500,11,0,0,150,0,0);
	G1_gate=FLine;//출발 선과 제일 가까운 G1 저장 
	Hm(180,400,11,0,0,1,4,200,0,0);
	FCC(1,2,1,165);
	
	LM(4,400,100,11,-50,150,-92,0);//현재 위치 : 출발/도착 
	
	FCC(2,0,1,165);//MidSET(psd[1]가 165만큼 붙을 때까지 이동)
	Pm(0,0,0,165,650,10,0,0,600,0,0);
	T=FLine; // T 저장 
	G1=G1_gate==T; // G1_gate가 T와 같다면 1, 다르다면 0 
	V1(11,0,0,0,0,180,0,240,0,0,0);
	Pm(0,0,0,165,650,00,0,0,50,0,0);//G1 중간에 위치 
	if(C_D[0][0]==T){ //T와 퍽이 같다면 
		Pm(0,0,0,165,650,01,0,0,550,0,0); 
		turn(1,100,11,20,0,0);//오른쪽으로 20도 돌기 
		FCC(2,0,4,135);//MidSET(psd[4]가 135만큼 붙을 때까지 이동)
		if(G1){ //T와 G1이 일치할 경우 (출발/도착에 가까운 곳) 
			Pm(5,0,1,135,650,11,1,5,230,0,0); 
			TD(-20,400,11,250,0,71,0);
		}
		else{ //T와 G1이 불 일치할 경우 (퍽과 가까운 곳)
			Pm(5,0,1,135,600,11,0,0,300,0,0);
			TD(-20,300,11,200,0,71,0);
		}
	}
	else{//T와 퍽이 다르다면 
			
		//현재 위치 : PUCK and 출발/도착 사이 
		
		if(G1){ //T와 G1이 일치할 경우 (출발/도착에  가까운 곳)
			Pm(0,0,0,165,650,01,0,0,150,0,0);

			turn(1,100,11,20,0,0);
			FCC(2,0,4,135);

			Pm(5,0,1,135,650,11,1,5,230,0,0);
			TD(-20,400,11,250,0,71,0);
		}//T와 G1이 불 일치할 경우 (퍽과 가까운 곳)
		else TD(0,500,01,500,0,97,0);
	}
	HM(0,300,11,50,0,0);
	FCC(1,2,1,165);//보정 
	
	if(G1){ //출발/도착에 가까운 G1
	// 3개 퍽 있는 구역으로 진입(맵 기준 아래) 
		turn(-1,100,11,20,0,0);
		HM(20,600,10,300,0,0);
		HM(20,600,01,0,-300,100);
		turn(1,100,11,20,0,0);
	}
	else{ //퍽과 가까운 G1
	//3개 퍽 있는 구역으로 진입 (맵 기준 아래) 
		TD(0,500,11,450,0,92,0);
		FCC(2,0,8,135);
		Pm(0,0,1,135,600,10,0,0,250,0,0);
		TD(0,500,01,500,0,-92,0);
	}
	
	attack3(1);//RB1 처리 
	
	//3개 퍽 처리 후 
	//출발/도착 벽 근처로 이동  
	LM(4,400,100,11,-80,150,-92,0);//현재 위치 : 맵지 기준(숫자 1) 
	FCC(2,0,1,165);//MidSET(psd[1]가 165만큼 붙을 때까지 이동) 
	
	//PUCK 쪽 벽 근처로 이동 
	Pm(0,0,0,165,650,10,0,0,400,0,0);
	Pm(0,0,1,135,650,00,0,0,250,0,0);
	TD(0,500,01,500,20,92,0);//현재 위치 : 맵지 기준(숫자 2) 
	HM(0,300,11,50,0,0);
	
	//(A)가변벽 근처에 있는  3개 퍽 처리하러 가는 중 
	
	FCC(1,0,4,230);//psd[4]가 230이 되도록 왼쪽 보정 
	FCC(2,0,1,165);//MidSET(psd[1]가 165만큼 붙을 때까지 이동)  
	Pm(0,0,0,165,650,10,0,0,350,0,0);
	TD(0,500,01,500,20,92,0);//현재 위치 : 맵지 기준(숫자 3) 
	HM(0,300,11,30,0,0);
	
	FCC(1,2,1,165);//psd[1]이 165가 되도록 뒷 보정 

	TD(0,500,11,500,0,92,0);//(A)가변벽 근처 3개 퍽 쪽으로 돌기 
	
	if(psd_value[5]<100) A=1;//맵지 기준(&)에 벽이 없음 
	else if(psd_value[3]<100) A=2;//맵지 기준(%)에 벽이 없음 
	else A=3;//맵지 기준(/)에 벽이 없음 

	ping(1);
	attack3(1);//RB2 처리 
	LM(1,400,100,11,5,100,-71,0);
	FCC(2,0,4,135);
	Pm(5,0,1,135,600,11,1,5,230,0,0);
	turn(-1,100,11,20,0,0);	
	FCC(1,2,1,165);//  현재 위치 : (숫자 3)에서 psd[1]이 165가 되도록 뒷 보정 
}
void M2()//A구역 가변벽 코드
{
	if(debug){
		//T=2;
		A=2;
	}

	FCC(1,2,1,165);//psd[1]이 165가 되도록 뒷 보정
	if(A==1){//맵지 기준(기호 &)로 이동
		TD(0,500,11,450,-10,-92,0);

		FCC(2,2,0,0);//MidSET (벽 사이에 보정)
		TD(0,450,11,450,0,45,0);
		TD(-45,400,11,100,300,-45,0);//현재 위치 : 맵지 기준(숫자 4)
		FCC(2,0,1,165);//MidSET(psd[1]가 165만큼 붙을 때까지 이동)  

	}
	else if(A==2){//맵지 기준(기호 %)로 이동
		Pm(0,0,0,165,650,10,0,0,250,0,0);
		TD(0,500,01,500,0,-92,0);

		FCC(2,2,0,0);//MidSET (벽 사이에 보정)
		Pm(0,2,2,150,600,10,0,0,550,0,0); //현재 위치 : 맵지 기준(숫자 4)
	}
	else if(A==3){//맵지 기준(기호 /)로 이동
		Pm(0,0,0,165,650,10,0,0,550,0,0);
		TD(0,500,01,500,0,-92,0);

		FCC(2,2,0,0);
		TD(0,450,11,450,0,-45,0);
		TD(45,400,11,70,-300,45,0);//현재 위치 : 맵지 기준(숫자 4)
		FCC(2,0,1,165);//MidSET(psd[1]가 165만큼 붙을 때까지 이동)  
	}
	Pm(0,0,0,165,600,01,0,0,450,0,60);//B구역 근처 3개 퍽 쪽으로 이동
	Pm(0,0,0,165,100,11,1,0,110,0,0);
	attack3(0);//B구역 근처 3개 퍽 처리
	turn(-1,100,11,20,0,0);
	FCC(2,0,3,135);//MidSET(psd[3]가 135만큼 붙을 때까지 이동)  
	Pm(4,2,2,150,600,11,0,0,520,0,0);//psd[4]로 거리 500가기          ****

	
	
	if(A==3){//뒤로 갔는데 가변벽이 있을 경우
		HM(20,500,11,-20,150,0);
		turn(-1,200,11,50,0,0);

		Pm(5,2,2,150,600,11,1,5,230,0,0);
	}
	else{//A구역 가운데만 가변벽이 없는 경우
		HM(20,500,11,0,150,0);
		turn(-1,200,11,50,0,0);
		
		FCC(2,0,4,135);//MidSET(psd[4]가 135만큼 붙을 때까지 이동)  
		Pm(5,0,1,135,600,11,1,5,230,0,0);
	}
	
	turn(-1,100,11,20,0,0);
	FCC(1,2,1,165);//psd[1]이 165가 되도록 뒷 보정 

	//현재 위치 : 맵지 기준(숫자 5)
}
void M3()//B-2 가변벽 해결후 맵지 기준(P4) 처리
{
	if(debug) T=2;
	
	FCC(1,2,1,165);
	TD(0,400,11,250,0,92,0);//코드 한 번 더 살펴봐야 함

	ping(1);
	Pm(0,2,2,150,500,10,0,0,100,0,0);
	Pm(0,0,0,165,500,00,1,0,60,0,0);//앞에 벽이 있을 때 까지 이동
	TD(0,400,01,300,0,92,0);
	HM(0,300,11,50,0,0);
	FCC(1,2,3,230);

	TD(0,300,11,200,-50,-90,0);
	FCC(1,1,0,0);
	FCC(2,0,8,135);

	Pm(0,0,1,135,650,11,0,0,1400-px[1],0,0);
	V1(0,0,0,0,0,180,0,240,130,90,1);
	FCC(2,0,8,135);
	attack2(0);//P4 처리

	turn(-1,100,11,20,0,0);
	FCC(2,0,5,165);//MidSET(psd[5]가 165만큼 붙을 때까지 이동)  
	Pm(4,0,0,165,600,11,0,0,400,0,0);//psd[4]로 거리 400가기
	TD(20,300,11,200,0,-71,0);
	HM(0,300,11,50,0,0);
	FCC(1,2,8,135);//psd[8]이 135가 되도록 뒷 보정

	//현재 위치 : 맵지 기준(숫자 6)
}
void M4()//P3, P2, P1 처리 
{
	FCC(1,2,8,135);//M3()에서 중복이 되므로 삭제 가능
	TD(0,400,11,350,0,92,0);//현재 위치 : 맵지 기준(숫자 7)
	HM(0,500,11,200,-150,0);//퍽 2개 쪽으로 가까이 가기
	attack2(1);//P3 처리
	Hm(180,400,11,0,0,1,4,230,0,0);//처리 후 뒤로 가기
	HM(0,300,11,-50,0,0);

	FCC(2,0,8,135);//psd[8]이 135가 되도록 뒷 보정
	turn(-1,200,11,90,0,0);
	FCC(2,0,1,130);//psd[1]이 135가 되도록 뒷 보정

	Pm(0,0,0,130,500,10,0,0,220,0,0);//P2 처리하러 앞으로 이동
	TD(0,400,01,350,50,92,0);//P2 쪽으로 돌기
	
	//현재 위치 : 맵지 기준(숫자 8)
	attack2(1);//P2 처리
	
	FCC(2,0,8,135);//psd[8]이 135가 되도록 뒷 보정
	HM(0,500,11,0,150,0);
	FCC(1,2,0,0);

	turn(-1,200,11,90,0,0);
	HM(0,500,11,350,-100,0);//8과9 사이를 이동
	TD(0,400,11,300,10,92,0);//현재 위치 : 맵지 기준(숫자 9)
	FCC(1,0,0,0);//왼쪽 보정
	
	ping(1);
	FCC(2,0,1,165);//psd[1]이 165가 되도록 뒷 보정
	Pm(0,0,0,165,600,11,0,0,200,0,0);//P1 퍽 쪽으로 이동
	attack2(0);//P1 처리
	turn(-1,100,11,20,0,0);
	FCC(2,0,3,135);//psd[3]이 135가 되도록 뒷 보정
	
	Pm(4,0,1,135,600,11,1,4,230,0,0);
	HM(20,300,11,-50,0,0);
	LM(1,400,0,11,0,350,-92,0); //ping(1)로 돌아오면서 오른쪽 350 이동, 왼쪽으로 92도 돔

	HM(0,500,11,-150,100,0);

	turn(-1,200,11,70,0,0);
	TD(-20,400,11,150,200,-22,0);
	FCC(2,0,1,165);//psd[1]이 165가 되도록 뒷 보정

	ping(1);
	Pm(0,0,0,165,500,10,1,0,60,0,0);
	TD(0,400,01,300,0,92,0);

	HM(0,300,11,50,0,0);
	FCC(1,2,3,230);//psd[3]가 230이 되도록 뒷 보정

	TD(0,300,11,200,-50,-90,0);
	FCC(1,1,0,0);//오른쪽 보정
	FCC(2,0,8,135);//MidSET(psd[8]가 135만큼 붙을 때까지 이동)  

	int len=1170-px[1];
	if(len>=600){//B-1 가변벽이 (왼 - > 오 순서)위 아래 일 경우
		Pm(0,0,1,135,500,10,0,0,len-500,0,0);
		TD(0,500,01,500,0,-92,0);
	}//B-1 가변벽이 (왼 - > 오 순서)아래 위 일 경우
	else TD(0,500,11,len,0,-92,0);

	HM(0,300,11,50,0,0);
	FCC(1,2,8,135);//psd[8]이 135가 되도록 뒷 보정
	//현재 위치 : 맵지 기준(숫자 10)
}
void M5()
{
	if(debug){
		A=1;
		G1=1;
	}

	FCC(1,2,8,135);//psd[8]이 135가 되도록 뒷 보정
	if(A==1){//맵지 기준(기호 &) 쪽으로 돌기
		TD(0,500,11,450,0,92,0);
	}
	else{//A의 값에 따라 (기호 %, /) 
		Pm(0,0,1,135,650,10,0,0,300*(A-1)-50,0,0);//이동
		TD(0,500,01,500,0,92,0);//돌기
	}
	FCC(2,2,0,0);//MidSET (벽 사이에서 보정)


	set(!G1);//G1이 0이면 1로 체인지, 1이면 0으로 체인지 
	//set(1) 왼쪽으로 돌기 (맵지 기준 : 출발/도착 선과 가까운 G1으로 이동)
	//stdir=1, dir=1, num=8, ta=135;
	//rev_stdir (-stdir) : -1
	//rev_dir (!dir) : 0
	//rev_num (9-num) : 1
	//rev_ta (ta==135 ? 165:135) : 165

	//set(0) 오른쪽으로 돌기 (맵지 기준 : PUCK과 가까운 G1으로 이동)
	//stdir=-1, dir=0, num=1, ta=165;
	//rev_stdir (-stdir) : 1
	//rev_dir (!dir) : 1
	//rev_num (9-num) : 8
	//rev_ta (ta==135 ? 165:135) : 135



	TD(0,500,11,500,0,92*rev_stdir,0);
	int a=dir?4-A:A;
	if(a==1){//가변벽(기호 /)로 이동한 경우
		FCC(2,2,0,0);
		TD(0,500,11,500,0,92*stdir,0);
	}
	else{//가변벽(기호 &, %)로 이동한 경우
		Pm(0,2,2,150,600,10,0,0,100,0,0);
		Pm(0,0,rev_dir,rev_ta,600,00,0,0,300*(a-1)-100,0,0);
		TD(0,500,01,500,0,92*stdir,0);
	}
	HM(0,300,11,50,0,0);
	FCC(1,2,rev_num,rev_ta);
	//현재 위치 : 맵지 기준 (숫자 11)
}
void M6()
{
	if(debug){
		G1=1;
	}
	set(!G1);//G1이 0이면 1로 체인지, 1이면 0으로 체인지 
	//set(1) 왼쪽으로 돌기 (맵지 기준 : 출발/도착 선과 가까운 G1으로 이동)
	//stdir=1, dir=1, num=8, ta=135;
	//rev_stdir (-stdir) : -1
	//rev_dir (!dir) : 0
	//rev_num (9-num) : 1
	//rev_ta (ta==135 ? 165:135) : 165

	//set(0) 오른쪽으로 돌기(맵지 기준 : PUCK과 가까운 G1으로 이동)
	//stdir=-1, dir=0, num=1, ta=165;
	//rev_stdir (-stdir) : 1
	//rev_dir (!dir) : 1
	//rev_num (9-num) : 8
	//rev_ta (ta==135 ? 165:135) : 135
	Pm(0,0,rev_dir,rev_ta,650,10,0,0,350,0,0);
	TD(0,500,01,500,0,40*stdir,0);
	TD(40*rev_stdir,400,11,50,300*stdir,40*rev_stdir,0);
	FCC(2,2,0,0);//MidSET (벽 사이에 보정)

	TD(0,500,11,450,0,71,0); 
	FCC(2,0,3,135);//psd[3]이 135가 되도록 이동
	Pm(4,0,1,135,650,11,1,4,230,0,0);//psd[4]이 value 230이 되도록 이동
	HM(20,300,11,-30,0,0);
	//현재 위치 : 출발/도착 선
}
void M7()
{
	
}
void M8()
{
	
}
void M9()
{

}

int main(void){
	unsigned char M_cnt=0;
    Interface_init();

	while(1)
	{
		if(SW1)
		{
			M_cnt++;
			PORTB=1;
			while(SW1);
			PORTB=0;
		}
		if(SW2)
		{
			M_cnt--;
			PORTB=2;
			while(SW2);
			PORTB=0;
		}
		if(SW3)
		{
			cls();
			WriteCommand(0,DFH);
			WriteCommand(1,DFH);
			WriteCommand(2,DFH);
			ping(0);
			debug=1;
			if(!M_cnt)
			{
				debug=0;
				M1(); M2(); M3(); M4(); M5(); M6(); M7(); M8(); M9();
				StopMotion(9);
				
				PORTB|=0x0F;
				_delay_ms(2000);
				PORTB&=~0x0F;
			}
			else if(M_cnt==1) M1();
			else if(M_cnt==2) M2();
			else if(M_cnt==3) M3();
			else if(M_cnt==4) M4();
			else if(M_cnt==5) M5();
			else if(M_cnt==6) M6();
			else if(M_cnt==7) M7();
			else if(M_cnt==8) M8();
			else if(M_cnt==9) M9();
			StopMotion(9);
		}
		if(SW4)
		{
			cls();
			WriteCommand(0,DFH);
			WriteCommand(1,DFH);
			WriteCommand(2,DFH);
			ping(0);

			Buzz(3);
			PORTB=1;
			while(SW4)
			{
				if(SW1) cls(), PORTB=1;
				if(SW2) cls(), PORTB=2;
				if(SW3) cls(), PORTB=4;

				if(PORTB&1)
				{	
					ping(0);
					sprintf(str,"    X = (%5d)",(int)px[0]); lcd_display_str(1,0,str);
					sprintf(str,"    Y = (%5d)",(int)py[0]); lcd_display_str(2,0,str);
					sprintf(str,"    W = (%5d)",(int)pw[0]); lcd_display_str(3,0,str);
				}
				if(PORTB&2)
				{
					dc(0,9,psd_value[0]);
					dc(0,4,psd_value[1]);dc(0,14,psd_value[8]);
					dc(1,0,psd_value[2]);dc(1,17,psd_value[7]);
					dc(2,0,psd_value[3]);dc(2,17,psd_value[6]);
					dc(3,4,psd_value[4]);dc(3,14,psd_value[5]);
				}
				if(PORTB&4)
				{
					V1(11,0,0,0,0,180,0,240,0,0,0);
					
					for(int i=0;i<5;i++){
						dc(0,i*4,C_D[i][0]);
						dc(1,i*4,C_D[i][1]);
						dc(2,i*4,C_D[i][2]);
					}

					dc(3,17,C_N);
				}
			}
			PORTB=0;
			cls();
		}
		dc(3,17,M_cnt);
	}
}

